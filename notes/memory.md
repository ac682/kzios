# 内存分配

机器模式没有内存分页，用户模式的内存分页应该支持所有模型，但实际上系统还没做去位元敏感化，只对 64 位有支持，分页也只简单实现了 Sv39。

## 写时复制

（因为写时复制的加入，页表引用会被多个进程共享，也就会有竞争条件，所以得加锁。）
（不需要给页表上锁，页表依旧是进程独有，且对两个页表的同时访问仅会在 fork 时发生，此时是串行。需要上锁的是物理页引用表。）
通过页表项的 `RSW` 作为 COW 的标志位，`WR`，低位表示采用引用共享，高位表示该页原先可写，即会触发 COW 发生。位于内存管理单元（`MemoryUnit`）中有列表保存各个物理页的引用次数，引用共享的页面只有在计数归零时被回收。当写入导致 Page Fault 发生时，若是 COW 置位的共享页，对于无 COW.W 直接以无内存写权限终止进程，有 COW.W 的则开始复制页并减少原先页面的引用次数。

这就引出了此前的一个问题，内核的内存管理模块如何处理进程的 Page Fault。如何判断是因为写入不可写的内存产生异常还是访问不存在的页产生异常。后者会在进程的栈到底时发生（堆的可以通过进程主动扩展来避免）。
答：Store Page Fault 时根据 mtval 可以找到出错地址所在的 PTE 来做进一步判断。
