# 任务模型

任务是个抽象概念，在内核中并存在具体结构，但依附于两种具体结构而存在：进程和线程。

## 进程，独立的执行环境

是用户作业所需要的资源，代码等上下文的集合，作为统一体被内核管理。进程数据包括其内存空间，进程的所有权限，父子进程关系，进程的调度状态（优先于线程调度状态）。

### 内存布局

进程的内存空间包含代码，数据，以及栈和堆等内存资源。这些资源存在于内存空间，但管理由另一种数据描述——内存布局，描述了程序各个段所在位置，栈的位置和分配状态，堆的位置和分配状态，共享内存的位置和状态。

### 权限

进程在 fork 时只能选择小于或等于父进程的权限进行继承。通过不同的权限集区分进程所属的级别，例如驱动程序拥有访问设备的能力。不同的权限通过系统调用中判断实现隔离。

## 线程，执行单元

进程参与调度但不具有执行上下文（PC，调用上下文），只有线程既是调度的主体又真正具有执行能力。

## 调度

每个核心都持有一个调度器，目前实现仅支持所有核心使用相同类型调度器。

当前版本使用平滑调度器 `SmoothScheduler` 作为实现。

### 平滑调度器

每个调度器维护一份进程列表，位于该调度器（核心）执行的进程在产生新进程时只会添加到当前调度器的列表中，不同调度器不共享进程列表。当进程列表为空时，调度器会尝试从其他核心偷取进程一个合适的进程，如果偷取失败则在 `idle_hart_mask` 中标记自身且进入低功耗等待。当一个调度器自主添加新进程且总量大于 1 时会按照 `idle_hart_mask` 发送 IPI。一个核心收到 IPI 将会进入重新进入循环——检查自身进程列表，当前情况进程列表为空，尝试偷取进程，调度或等待。

进程列表被用作环形数组使用，每次调度发生时除检查进程列表是否为空的情况外，会按照进程列表检查下一个就绪进程。每个进程和线程都包含自身的代数 `generation`，用以描述其得到执行权的次数；调度器也有代数，用以记录进程列表代数最大的那一个。首先进程获得执行权需要其代数不大于调度器记录的最大代数，只要一直保持小于或等于状态就能一直获得或保持执行权。其次检查以该进程的代数作为目标检查其线程的代数是否满足不大于的要求，以决定获得执行权的线程。一旦线程获得执行权，在真正执行之前，如果代数大于进程代数那么更新，如果进程代数大于调度器代数那么更新。

#### 进程迁移

富有核心在获得新进程时会检查是否满足迁移条件，然后将新进程放至缓冲区，向 `idle_hart_mask` 中的第一位发送 IPI 通知取出缓冲区进程。

#### 缺陷

这么做存在缺陷。每次调度都会先选择进程，一个进程被选择后其他核心讲无法选中，避免了一个进程四个线程位于四个核心上执行的可能，降低了 CPU 缓存效率。其次代数只判断不小于，意味着一个进程拥有 n 个线程则其命中调度次数将是其他 m 个线程进程的 n/m 倍次。

进程迁移机制只在新进程添加时发生，如果没有进程添加则永远不会进行负载平衡。

### 足够公平调度器

基于平滑调度器做出以下修改：进程列表共享，进程被选中并不影响其他核心继续选中，进程列表的代数表示每个进程的代数和，进程的代数表示每个进程的代数和。由于进程列表共享，不再需要进程迁移机制。
