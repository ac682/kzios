# 任务模型

任务是个抽象概念，在内核中并存在具体结构，但依附于两种具体结构而存在：进程和线程。

## 进程，独立的执行环境

是用户作业所需要的资源，代码等上下文的集合，作为统一体被内核管理。进程数据包括其内存空间，进程的所有权限，父子进程关系，进程的调度状态（优先于线程调度状态）。

### 内存布局

进程的内存空间包含代码，数据，以及栈和堆等内存资源。这些资源存在于内存空间，但管理由另一种数据描述——内存布局，描述了程序各个段所在位置，栈的位置和分配状态，堆的位置和分配状态，共享内存的位置和状态。

### 权限

进程在 fork 时只能选择小于或等于父进程的权限进行继承。通过不同的权限集区分进程所属的级别，例如驱动程序拥有访问设备的能力。不同的权限通过系统调用中判断实现隔离。

## 线程，执行单元

进程参与调度但不具有执行上下文（PC，调用上下文），只有线程既是调度的主体又真正具有执行能力。

## 调度

每个核心都持有一个调度器，目前实现仅支持所有核心使用相同类型调度器。

当前版本使用平滑调度器 `SmoothScheduler` 作为实现。

### 平滑调度器

每个调度器维护一份进程列表，位于该调度器（核心）执行的进程在产生新进程时只会添加到当前调度器的列表中，不同调度器不共享进程列表。当进程列表为空时，调度器会尝试从其他核心偷取进程一个合适的进程，如果偷取失败则在 `idle_hart_mask` 中标记自身且进入低功耗等待。当一个调度器自主添加新进程且总量大于 1 时会按照 `idle_hart_mask` 发送 IPI。一个核心收到 IPI 将会进入重新进入循环——检查自身进程列表，当前情况进程列表为空，尝试偷取进程，调度或等待。

进程列表被用作环形数组使用，每次调度发生时除检查进程列表是否为空的情况外，会按照进程列表检查下一个就绪进程。每个进程和线程都包含自身的代数 `generation`，用以描述其得到执行权的次数；调度器也有代数，用以记录进程列表代数最大的那一个。首先进程获得执行权需要其代数不大于调度器记录的最大代数，只要一直保持小于或等于状态就能一直获得或保持执行权。其次检查以该进程的代数作为目标检查其线程的代数是否满足不大于的要求，以决定获得执行权的线程。一旦线程获得执行权，在真正执行之前，如果代数大于进程代数那么更新，如果进程代数大于调度器代数那么更新。

#### 进程迁移机制（基于 IPI，待定）

即偷取过程。由于进程列表包括锁都由调度器持有（因此进程列表其实可以不加锁），其他核心想要获取“所有核心上的调度器所持有的代数最少且不在调度也不在执行中的就绪进程”需要通过一种远程调用方式让调取主动让出。此处引入 `RemoteCall` 这种通过 IPI 的调用方式。远程调用的一种是通知调度 `ScheduleNotify`，还有一种是进程出让 `ScheduleTransfer`。

IPI 机制用于远程调用是合理的，但调度器实现不应该规定远程调用的内容，IPI 本身的作用是通知核心进入调度，在没有进程迁移机制实现下这一点与平滑调度器天然契合。
